

<script>
var PxVisBehaviorDebug = PxVisBehaviorDebug || {};

/*
    Name:
    PxVisBehaviorDebug.base

    Description:
    Polymer behavior that provides base props and functions for debugging

    Dependencies:
    - none

    @polymerBehavior PxVisBehaviorDebug.base
*/
PxVisBehaviorDebug.base = {

  properties: {
    _preventLog: {
      type: Boolean,
      value: false
    },

    _isParaRadar: {
      type: Boolean
    }
  },

  attached: function() {
    this._isParaRadar = this.nodeName === 'PX-VIS-PARALLEL-COORDINATES' || this.nodeName === 'PX-VIS-RADAR';
  },

  _debugObjectHasKeys: function(obj, toFind) {
    var result = {
          hasKeys: false,
          otherKeys: []
        },
        keyCount = 0,
        keys;

    if(obj) {
      keys = Object.keys(obj);

      for(var i=0; i<keys.length; i++) {
        if(obj.hasOwnProperty(keys[i])) {
          if(toFind.indexOf(keys[i]) === -1) {
            otherKeys.push(keys[i]);
          } else {
            keyCount++;
          }
        }
      }

      if(keyCount === toFind.length) {
        result.hasKeys = true;
      }
    }

    return result;
  },

  _debugGetTimeKey: function() {

    var timeKey;

    if(this.timeData) {
      timeKey = this.timeData;
    } else if(this.seriesKey) {
      timeKey = this.seriesKey;
    } else {
      timeKey = this.completeSeriesConfig[Object.keys(this.completeSeriesConfig)[0]].x;
    }

    return timeKey;
  },

  _debugGetSeriesKeys: function() {

    if(this._isParaRadar) {
      return this.dimensions;
    } else {
      return Object.keys(this.completeSeriesConfig);
    }
  },

  _debugLog: function(msg) {
    console.warn(msg);
    this.hasLogged = true;
  },

  _debugTitle: function(msg) {
    console.log('Checking ' + msg);
    var separator = '=========';
    for(var i=0; i< msg.length; i++) {
      separator += '=';
    }
    console.log(separator);
  },

  _debugWarn: function(msg) {
    console.log(msg);
    this.hasLogged = true;
  },

  _getAllPropertiesKeys: function() {
    var result = Object.keys(this.properties);

    for(var i=0; i<this.behaviors.length; i++) {
      if(this.behaviors[i].properties) {
        result = result.concat(Object.keys(this.behaviors[i].properties));
      }
    }

    return result;
  }
};

/*
    Name:
    PxVisBehaviorDebug.check

    Description:
    Polymer behavior that checks if configs are valid

    Dependencies:
    - none

    @polymerBehavior PxVisBehaviorDebug.check
*/
PxVisBehaviorDebug.check = [{

  _checkDebugConfig: function() {

    if(this._isParaRadar) {
      this._debugCheckConfigInfoParaRadar();
    }
    this._debugCheckChartExtents();
    this._debugCheckMargin();
  },

  _debugCheckConfigInfoParaRadar: function() {

    var current,
        keys;

    //check axes
    for(var i=0; i<this.dimensions.length; i++) {
      current = this.dimensions[i];
      if(this.seriesConfig[current]) {
        keys = Object.keys(this.seriesConfig[current]);

        for(var j=0; j<keys.length; j++) {
          if(keys[i] !== 'title' || keys[i] !== 'yAxisUnit') {

            if(!this._preventLog) {
              console.warn('Unrecognized key "' + keys[i] + '" for axis ' + current + ' in seriesConfig. Axis can only have "title" and/or "yAxisUnit". Please delete');
            }
          }
        }
      }
    }

    //check categories
    if(this.categories) {
      if(!this.categoryKey) {

        this._debugLog('categories are defined but categoryKey isn\'t. This is valid but categories won\'t be used.');
      }

      for(var i=0; i<this.categories.length; i++) {
        current = this.categories[i];
        if(this.seriesConfig[current]) {
          keys = Object.keys(this.seriesConfig[current]);

          for(var j=0; j<keys.length; j++) {
            if(keys[i] !== 'color') {

              this._debugWarn('Unrecognized key "' + keys[i] + '" for category ' + current + ' in seriesConfig. Categories can only have "color". Please delete');
            }
          }
        }
      }
    } else if(this.categoryKey) {
      if(!this.categoryKey) {

        this._debugLog('categoryKey is defined but categories aren\'t. This is valid but categories won\'t be used.');
      }
    }

    //check for series
    var timeKey = this._debugGetTimeKey();

    if(this.seriesConfig[timeKey]) {
      for(var j=0; j<keys.length; j++) {
        if(keys[i] !== 'color') {

          this._debugWarn('Unrecognized key "' + keys[i] + '" for the time based series ' + timeKey + ' in seriesConfig. Series can only have "color". Please delete');
        }
      }
    }
  },

  _debugCheckMargin: function() {

    var valid = this._debugObjectHasKeys(this.margin, ['top', 'bottom', 'left', 'right']);

    if(!valid.hasKeys) {
      console.warn('`margin` property must be an object with "top", "bottom", "left" and "right" properties (numbers).')
    }
    if(valid.otherKeys.length) {
      console.warn('`margin` property can\'t have other properties than "top", "bottom", "left" and "right". invalid properties: ' + JSON.stringify(valid.otherKeys));
    }
  },

  _debugCheckChartExtents: function() {

    this._debugTitle('chartExtents');

    if(this.chartExtents) {
      var keys = Object.keys(this.chartExtents),
          current;

      for(var i=0; i<keys.length; i++) {

        current = this.chartExtents[keys[i]];
        if(!Array.isArray(current) || current.length !== 2) {

          this._debugWarn('chartExtents key ' + keys[i] + ' is not an array of 2 values: ' + JSON.stringify(current));
        } else {
          if(current[0] !== 'dynamic' && isNan(parseFloat(current[0])) || current[0] === Infinity || current[0] === -Infinity) {
            this._debugWarn('chartExtents key ' + keys[i] + ' should only have numbers, string representing a number or "dynamic". Current value: ' + JSON.stringify(current));
          }
          if(current[1] !== 'dynamic' && isNan(parseFloat(current[1])) || current[1] === Infinity || current[1] === -Infinity) {
            this._debugWarn('chartExtents key ' + keys[i] + ' should only have numbers, string representing a number or "dynamic". Current value: ' + JSON.stringify(current));
          }
        }
      }
    }
  }
}, PxVisBehaviorDebug.base];

/*
    Name:
    PxVisBehaviorDebug.getInfo

    Description:
    Polymer behavior that gets debug information for a chart

    Dependencies:
    - none

    @polymerBehavior PxVisBehaviorDebug.getInfo
*/
PxVisBehaviorDebug.getInfo = [{

  _getDebugInfo: function(log) {

    var info = {};

    info.timeStamp = new Date();
    info.chartType = this.nodeName;

    this._debugAddDataInfo(info);
    this._debugAddConfigInfo(info);
    this._debugAddExtentsInfo(info);
    this._debugAddSubCompInfo(info);
    this._debugAddMiscInfo(info);
    // this._debugAddRendererInfo(info);

    if(log) {
      console.log(JSON.stringify(info, null, 2));
    }

    return info;
  },

  _debugAddDataInfo: function(info) {

    var data = {},
        extents = {};
    info.hasData = !!this.chartData;

    if(info.hasData) {

      var timeKey = this._debugGetTimeKey(),
          seriesKeys = this._debugGetSeriesKeys(),
          min = Number.MAX_VALUE,
          max = Number.MIN_VALUE;

      data.length = this.chartData.length;
      data.timeStart = this.chartData[0][timeKey];
      data.timeStartHuman = Px.moment(this.chartData[0][timeKey]).format();
      data.timeEnd = this.chartData[this.chartData.length - 1][timeKey];
      data.timeEndHuman = Px.moment(this.chartData[this.chartData.length - 1][timeKey]).format();

      for(var i=0; i<seriesKeys.length; i++) {
        extents[seriesKeys[i]] = Px.d3.extent(this.chartData, function(d) {
          return d[seriesKeys[i]];
        });
        min = Math.min(extents[seriesKeys[i]][0], min);
        max = Math.max(extents[seriesKeys[i]][1], max);
      }

      data.extents = extents;
      data.min = min;
      data.max = max;
    }

    info.data = data;
  },

  _debugAddConfigInfo: function(info) {

    info.config = {};

    info.config.seriesConfig = this.seriesConfig;
    info.config.completeSeriesConfig = this.completeSeriesConfig;

    if(this._isParaRadar) {
      info.config.dimension = this.dimensions;
      info.config.axes = this.axes;
    }
    //TODO: check XY/TS/Polar conf?
  },

  _debugAddMiscInfo: function(info) {
    info.misc = {};
    info.misc.margin = this.margin;
  },

  _debugAddExtentsInfo: function(info) {

    info.extents = {};

    info.extents.chartExtents = this.chartExtents;
    info.extents.dataExtents = this.dataExtents;

    if(typeof this.y === 'function') {
      info.extents.y = {};
      info.extents.y.domain = this.y.domain();
      info.extents.y.range = this.y.range();
    } else {
      var keys = Object.keys(this.y);

      info.extents.y = {};
      for(var i=0; i<keys.length; i++) {
        info.extents.y[keys[i]] = {};
        info.extents.y[keys[i]].domain = this.y[keys[i]].domain();
        info.extents.y[keys[i]].range = this.y[keys[i]].range();
      }
    }

    info.extents.x = {};
    info.extents.x.domain = this.x.domain();
    info.extents.x.range = this.x.range();
  },

  _debugAddSubCompInfo: function(info) {
    info.subConfigs = {};

    var keys = this._getAllPropertiesKeys();

    for(var i=0; i<keys.length; i++) {
      if(/^[^_]*Config/.test(keys[i]) && keys[i] !== 'seriesConfig' && keys[i] !== 'completeSeriesConfig') {
        info.subConfigs[keys[i]] = this[keys[i]];
      }
    }
  }
}, PxVisBehaviorDebug.base];

/*
    Name:
    PxVisBehaviorDebug.full

    Description:
    Polymer behavior that gets debug information for a chart and allow to check for config validity

    Dependencies:
    - none

    @polymerBehavior PxVisBehaviorDebug.full
*/
PxVisBehaviorDebug.full = [PxVisBehaviorDebug.check, PxVisBehaviorDebug.getInfo];

</script>
