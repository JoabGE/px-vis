<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-tooltip/px-tooltip.html" />
<link rel="import" href="px-vis-behavior-common.html" />
<link rel="import" href="px-vis-behavior-d3.html" />
<link rel="import" href="px-vis-scatter-canvas.html" />
<link rel="import" href="../app-localize-behavior/app-localize-behavior.html"/>
<link rel="import" href="px-vis-behavior-datetime.html"/>
<link rel="import" href="css/px-vis-styles.html">

<!--

### Usage

    <px-vis-svg
        ...
        svg="{{svg}}">
    </px-vis-svg>
    <px-vis-scale
        ...
        x="{{x}}"
        y="{{y}}"
        domain-changed="{{domainChanged}}">
    </px-vis-scale>
    <px-vis-interaction-space
        ...
        generating-crosshair-data="{{generatingCrosshairData}}"
        crosshair-data="{{crosshairData}}">
    </px-vis-interaction-space>

    <px-vis-markers
        svg="[[svg]]"
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]"
        time-data="[[key]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-data="[[chartData]]"
        generating-crosshair-data="[[generatingCrosshairData]]"
        crosshair-data="[[crosshairData]]">
    </px-vis-markers>

### Styling
The following custom properties are available for styling:

Custom property | Description
:----------------|:-------------
  `--px-vis-cursor-line-color` | The color for the lines which track the cursor/data


@element px-vis-markers
@blurb Element which draws markers on top or bottom of a chart
@homepage index.html
@demo demo/index.html

-->

<dom-module id="px-vis-markers">
    <template>
      <style include="px-vis-styles"></style>

      <template is="dom-repeat" items="[[_markerTypes]]">
        <px-vis-scatter-canvas
          canvas-context="[[canvasContext]]"
          series-id="[[item]]"
          clip-path
          chart-data="[[_returnMarkerData(item, _markerData)]]"
          complete-series-config="[[_markerConfig]]"
          width="[[width]]"
          height="[[height]]"
          margin="[[_returnMargin(margin.*)]]"
          x="[[x]]"
          y="[[_returnYScale(item, _topDomain, _bottomDomain)]]"
          domain-changed="[[_returnDomain(item, _topDomain, _bottomDomain, domainChanged)]]"
          progressive-rendering-points-per-frame="500"
          renderer-type="markers">
        </px-vis-scatter-canvas>
      </template>
      <template id="tooltipIf" is="dom-if" if="[[_showTooltip]]">
        <px-tooltip
          id="tooltip"
          follow-mouse
          delay="50"
          smart-orientation
          for="[[_canvas]]"
          mouse-coords="[[_tooltipPosition]]"
          tooltip-message="[[_ttMessage]]">
          <span>
            <b>[[localize("Event")]]</b>: [[_eventType]] <br/>
            <b>[[localize("Timestamp")]]</b>: [[_value]]<br/>
          </span>
        </px-tooltip>
      </template>
    </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-markers',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.canvasContext,
      PxVisBehaviorD3.axes,
      PxVisBehavior.dataset,
      PxVisBehavior.commonMethods,
      PxVisBehaviorD3.clipPath,
      PxVisBehavior.dynamicConfigProperties,
      PxVisBehavior.markers,
      PxVisBehaviorTime.datetime,
      Polymer.AppLocalizeBehavior
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      _markerData: {
        type:Object,
        computed: '_computeMarkerData(markerData.*, _markerTypes.*)'
      },

      _markerConfig: {
        type:Object,
        computed: '_computeMarkerConfig(markerConfig.*)'
      },

      _markerTypes: {
        type: Array
      },

      _topScale: {
        type: Function
      },

      _bottomScale: {
        type: Function
      },

      _topDomain: {
        type: Boolean,
        value: null
      },

      _bottomDomain: {
        type: Boolean,
        value: null
      },

      _canvas : {
        type: Object,
        computed: '_getCanvas(canvasContext)'
      },

      /**
       * how close to a point the mouse has to be before we show a tooltip
       */
      tooltipDetectionRadius: {
        type: Number,
        value: 10
      },

      _tooltipPosition: {
        type: Array
      },
      /**
       * List of keys & values used for translating this component.
       */
       resources: {
        type: Object,
        value: function() {
          return {
            'en': {
              'Event': 'Event',
              'Timestamp': 'Timestamp'
            }
          };
        }
      },
      /**
       * A valid IETF language tag as a string that will be
       * used to localize this component.
       *
       * See https://github.com/PolymerElements/app-localize-behavior for API
       * documentation and more information.
       */
      language: {
        type: String,
        value: 'en'
      },
      /**
      * Use the key for localization if value for language is missing.
      * Should always be true for Predix components.
      */
     useKeyIfMissing: {
       type: Boolean,
       value: true
     },

     _eventType: {
       type: String
     },

     _value: {
       type: String
     },

     _showTooltip: {
       type: Boolean,
       value: false
     }

    }, //properties

    observers: [
      '_requestCanvasCreation(markerConfig, height, margin.*)',
      '_createScales(height, margin.*, _markerTypes.*)',
      '_redraw(domainChanged)'
    ],

    _computeMarkerConfig: function() {
      var types = Object.keys(this.markerConfig),
          defaultKeys = Object.keys(this._defaultMarkerConfig),
          type,
          config = {};

      for(var i=0; i < types.length; i++) {
        type = types[i];
        config[type] = {
          x: 'x',
          y: type
        };

        //fill default if needed
        for(var j=0; j<defaultKeys.length; j++) {
            config[type][defaultKeys[j]] = (this.markerConfig[type][defaultKeys[j]] || this.markerConfig[type][defaultKeys[j]] === false || this.markerConfig[type][defaultKeys[j]] === 0) ? this.markerConfig[type][defaultKeys[j]] : this._defaultMarkerConfig[defaultKeys[j]];
        }

        //treat fill and tooltipLabel differently
        config[type]['markerFillOpacity'] = this._getFillOpacity(this.markerConfig[type].markerFillOpacity, config[type]['markerFillOpacity']);
        config[type]['tooltipLabel'] = this._defaultMarkerConfig['tooltipLabel'] ? this._defaultMarkerConfig['tooltipLabel'] : type;
      }

      this.set('_markerTypes', types);

      return config;
    },

    _getFillOpacity: function(fill,stroke) {
      // if we have a fill, use it
      if(fill) { return fill; }
      // if we dont have a fill or stroke, set fill to 1
      if(!stroke) { return 1}
      // else, set to 0
      return 0
    },

    _computeMarkerData: function() {
      if(!this.markerData || this.markerData.length === 0) {
        return [];
      }

      var data = this._prepDataObject(this._markerTypes),
          type,
          row,
          time,
          o;

      for(var i=0; i<this.markerData.length; i++) {
        time = this.markerData[i]['time'];
        type = this.markerData[i]['label'];
        row = this.markerConfig[type]['row'] ? this.markerConfig[type]['row'] : 0;

        o = {};
        o.x = time;
        o[type] = row;
        data[type].push(o);
      }

      return data;
    },

    _prepDataObject: function(types) {
      var data = {};

      for(var i=0; i<types.length; i++) {
        data[types[i]] = [];
      }

      return data;
    },

    _requestCanvasCreation: function() {
      this.set('canvasLayersConfig.markers', {
        height: this.height,
        margin: { top: 0, bottom: 0, left: this.margin.left, right: this.margin.right }
      });
    },

    _createScales: function() {
      this.debounce('createScalesMarker', function() {
        this._createScalesDebounced();
      }, 10);
    },

    _createScalesDebounced: function() {
      var tH = this.margin.top,
          bH = this.height - this.margin.bottom,
          tRowSet = {},
          bRowSet = {},
          tRow,
          bRow,
          tScale,
          bScale,
          type;

      for(var i=0; i<this._markerTypes.length; i++) {
        type = this._markerTypes[i];
        row = this.markerConfig[type]["row"];

        if(this.markerConfig[type]['location'] === "bottom") {
          bRowSet[row] = true;
        } else {
          tRowSet[row] = true;
        }
      }

      bRow = Object.keys(bRowSet);
      tRow = Object.keys(tRowSet);

      bScale = Px.d3.scalePoint()
        .range([bH, this.height])
        .padding(0.5)
        .domain(bRow);
      tScale = Px.d3.scalePoint()
        .range([0, tH])
        .padding(0.5)
        .domain(tRow);

      this.set('_bottomScale', bScale);
      this.set('_topScale', tScale);

      this.set('_bottomDomain', (this._bottomDomain === null) ? true : !this._bottomDomain);
      this.set('_topDomain', (this._topDomain === null) ? true : !this._topDomain);
    },

    _returnYScale: function(item) {
      if(this._topDomain !== null && this._bottomDomain !== null) {
        return this.markerConfig[item]["location"] === "bottom" ? this._bottomScale : this._topScale;
      }
    },

    _returnDomain: function(item) {
      if(this._topDomain !== null && this._bottomDomain !== null && this.domainChanged !== null) {
        return this.markerConfig[item]["location"] === "bottom" ? this._bottomDomain : this._topDomain;
      }
    },

    _returnMarkerData: function(item) {
      return this._markerData[item];
    },


    _returnMargin: function() {
      return { top: 0, bottom: 0, left: this.margin.left, right: this.margin.right };
    },

    _redraw: function() {
      if(this._topDomain !== null && this._bottomDomain !== null && this.domainChanged !== null) {
        this.set('_bottomDomain', !this._bottomDomain);
        this.set('_topDomain', !this._topDomain);
      }
    },

    _mouseMove: function(evt) {

      var mousePos = Px.d3.mouse(this._canvas);

      if(mousePos[0] > this.margin.left && mousePos[0] < (this.width - this.margin.right) && mousePos[1] > 0) {

        //adjust mouse pos to get correct time
        adjustedMousePos = [mousePos[0] - this.margin.left, mousePos[1]];
        //figure out which row we're hovering
        var rowInfo = this._getRowInfoForMouse(mousePos);

        if(rowInfo.index) {

          //find all marker types for this row
          var labels = this._findLabelsForRow(rowInfo.index),
              data = [],
              bisect = Px.d3.bisector(function(d) {
                  return d.x;
              }.bind(this)).left,
              maxDomain = this.x.domain()[1],
              minDomain = this.x.domain()[0],
              mouseTime = this.x.invert(adjustedMousePos[0]),
              left,
              right,
              pixelResult = [],
              dataResult;

          //get data for all labels we're interested in
          for(var i=0; i<labels.length; i++) {
            data = data.concat(this._markerData[labels[i]]);
          }

          //search for point on left and right
          left = bisect(data, mouseTime) - 1;
          right = left ? left+1 : data.length;

          //decide which point to pick
          if(!data[left] || data[left].x < minDomain) {
            //out of bound on left
            dataResult = data[right];
          } else if(!data[right] || data[right].x > maxDomain) {
            //out of bound on right
            dataResult = data[left];
          } else if(data[right] && (data[right].x - mouseTime) < (mouseTime - data[left].x)) {
            //closer to right
            dataResult = data[right];
          } else if(data[left]) {
            //closer to left
            dataResult = data[left];
          }

          this._updateTooltip(mousePos, pixelResult, dataResult, rowInfo);
        }
      }
    },

    _updateTooltip: function(mousePos, pixelResult, dataResult, rowInfo) {

      var tooltipUpdated = false;
      if(dataResult) {

        var type,
            dataKey = Object.keys(dataResult);

        for(var i=0; i<dataKey.length; i++) {
          if(this._markerTypes.indexOf(dataKey[i]) !== -1) {
            type = dataKey[i];
            break;
          }
        }

        if(type && this._markerConfig[type].showTooltip) {

          pixelResult[0] = this.x(dataResult.x) + this.margin.left ;

          //only show if we're close enough
          if(Math.abs(pixelResult[0] - mousePos[0]) <= this.tooltipDetectionRadius) {

            //adjust pixel values to take canvas position into account
            pixelResult[0] += (Px.d3.event.pageX - mousePos[0]);
            pixelResult[1] = Px.d3.event.pageY - mousePos[1] + rowInfo.rowY;

            //update everything the tooltip needs
            this.set('_value', this._formatTimestampForType(dataResult, type));
            this.set('_eventType', this._markerConfig[type].tooltipLabel);
            this.set('_tooltipPosition', pixelResult);
            this.set('_showTooltip', true);

            //TODO: check if needed
            this._checkForTooltip();
            this.$.tooltip.orientation = this._markerConfig[type].tooltipOrientation;
            this.$.tooltip._show();
            tooltipUpdated = true;
          }
        }
      }

      if(this.$.tooltip && !tooltipUpdated && (this.$.tooltip._isShowing || this.$.tooltip._requestShow)) {
        this.$.tooltip._hide();
      }
    },

    _checkForTooltip: function() {

      //if the tooltip had never been rendered yet force it and store it for further use
      if(!this.$.tooltip) {
        this.$.tooltipIf.render();
        this.$.tooltip = this.$$('px-tooltip');
      }
    },

    _formatTimestampForType: function(data, type) {
      var conf = this._markerConfig[type];

      return  this.formatTimestamp(data.x, conf.timezone, conf.firstDateTimeFormat) +
      ' ' + conf.separator + ' ' + this.formatTimestamp(data.x, conf.timezone,conf.secondDateTimeFormat);
    },

    _getRowInfoForMouse: function(mousePos) {
      var top = mousePos[1] <= this.margin.top ? true : false,
            yStart,
            scale,
            domain,
            availableSpace,
            domainIndex = 0,
            rowHeight,
            rowY;

        //init based on bottom or top rows
        if(top) {
          yStart = 0;
          scale = this._topScale;
          availableSpace = this.margin.top;
        } else {
          yStart = this.height - this.margin.bottom;
          scale = this._bottomScale;
          availableSpace = this.margin.bottom;
        }
        domain = scale.domain();

        //find which row we're hovering
        if(domain.length) {
          rowHeight = availableSpace/domain.length;
          domainIndex = Math.floor((mousePos[1] - yStart) / rowHeight);
          rowY = yStart + (domainIndex + 0.5) * rowHeight;
        } else {
          rowY = yStart + availableSpace/2;
        }

        return {'index': domain[domainIndex], 'rowY': rowY};
    },

    _findLabelsForRow: function(rowIndex) {
      var keys = Object.keys(this.markerConfig),
          result = [];

      rowIndex = Number(rowIndex);

      for(var i=0; i<keys.length; i++) {
        if(rowIndex === this.markerConfig[keys[i]].row || (rowIndex === 0 && !this.markerConfig[keys[i]].row)) {
          result.push(keys[i]);
        }
      }

      return result;
    },

    _getCanvas: function() {
      if(this.canvasContext) {

        if(this._canvas === undefined) {

          //register handlers the first time
          Px.d3.select(this.canvasContext.canvas).on('mousemove.markers', this._mouseMove.bind(this));
        }

        return this.canvasContext.canvas;
      }
    }
  });
</script>
